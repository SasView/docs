<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sas.sascalc.fit.expression &#8212; SasView 5.0.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/classic.css" />
    
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SasView 5.0.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../sas.html" accesskey="U">sas</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">sas.sascalc.fit.expression</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sas.sascalc.fit.expression</h1><div class="highlight"><pre>
<span></span><span class="c1"># This program is public domain</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Parameter expression evaluator.</span>

<span class="sd">For systems in which constraints are expressed as string expressions rather</span>
<span class="sd">than python code, :func:`compile_constraints` can construct an expression</span>
<span class="sd">evaluator that substitutes the computed values of the expressions into the</span>
<span class="sd">parameters.</span>

<span class="sd">The compiler requires a symbol table, an expression set and a context.</span>
<span class="sd">The symbol table maps strings containing fully qualified names such as</span>
<span class="sd">&#39;M1.c[3].full_width&#39; to parameter objects with a &#39;value&#39; property that</span>
<span class="sd">can be queried and set.  The expression set maps symbol names from the</span>
<span class="sd">symbol table to string expressions.  The context provides additional symbols</span>
<span class="sd">for the expressions in addition to the usual mathematical functions and</span>
<span class="sd">constants.</span>

<span class="sd">The expressions are compiled and interpreted by python, with only minimal</span>
<span class="sd">effort to make sure that they don&#39;t contain bad code.  The resulting</span>
<span class="sd">constraints function returns 0 so it can be used directly in a fit problem</span>
<span class="sd">definition.</span>

<span class="sd">Extracting the symbol table from the model depends on the structure of the</span>
<span class="sd">model.  If fitness.parameters() is set correctly, then this should simply</span>
<span class="sd">be a matter of walking the parameter data, remembering the path to each</span>
<span class="sd">parameter in the symbol table.  For compactness, dictionary elements should</span>
<span class="sd">be referenced by .name rather than [&quot;name&quot;].  Model name can be used as the</span>
<span class="sd">top level.</span>

<span class="sd">Getting the parameter expressions applied correctly is challenging.</span>
<span class="sd">The following monkey patch works by overriding model_update in FitProblem</span>
<span class="sd">so that after setp(p) is called and, the constraints expression can be</span>
<span class="sd">applied before telling the underlying fitness function that the model</span>
<span class="sd">is out of date::</span>

<span class="sd">        # Override model update so that parameter constraints are applied</span>
<span class="sd">        problem._model_update = problem.model_update</span>
<span class="sd">        def model_update():</span>
<span class="sd">            constraints()</span>
<span class="sd">            problem._model_update()</span>
<span class="sd">        problem.model_update = model_update</span>

<span class="sd">Ideally, this interface will change</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">keyword</span> <span class="kn">import</span> <span class="n">iskeyword</span>

<div class="viewcode-block" id="standard_symbols"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression.standard_symbols">[docs]</a><span class="k">def</span> <span class="nf">standard_symbols</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="p">{}):</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">symbols</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
    <span class="n">symbols</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">arcsin</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">asin</span><span class="p">,</span> <span class="n">arccos</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">,</span>
                        <span class="n">arctan</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">,</span> <span class="n">arctan2</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">))</span>
    <span class="n">symbols</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="n">symbols</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">id</span>
    <span class="k">return</span> <span class="n">symbols</span></div>

<div class="viewcode-block" id="_check_syntax"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._check_syntax">[docs]</a><span class="k">def</span> <span class="nf">_check_syntax</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">compile</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">html</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
                <span class="c1"># Multiline expression. Be lazy and just show line, col for</span>
                <span class="c1"># syntax error since this should never happen.</span>
                <span class="k">return</span> <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;Syntax error on line </span><span class="si">{</span><span class="n">exc</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> column </span><span class="si">{</span><span class="n">exc</span><span class="o">.</span><span class="n">offset</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&lt;pre&gt;</span><span class="se">\n</span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="se">\n</span><span class="s2">&lt;/pre&gt;&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">exc</span><span class="o">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="c1"># Single line expression with error after the expression.</span>
                <span class="c1"># Probably missing a closing paren, but it could</span>
                <span class="c1"># also be that the expression ends with an operator such as</span>
                <span class="c1"># &quot;3+4+&quot;</span>
                <span class="k">return</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Expression `</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">` is not complete.&quot;</span><span class="p">]</span>

            <span class="c1"># Single line expression. Wrap the tail of the expr after the</span>
            <span class="c1"># syntax error in &lt;b&gt;...&lt;/b&gt;. exc.lineno=1, exc.text = expr+&quot;\n&quot;,</span>
            <span class="c1"># and exc.offset = location of the syntax error in expr.</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;Syntax error in expression &#39;</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">expr</span><span class="p">[:</span><span class="n">exc</span><span class="o">.</span><span class="n">offset</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&lt;b&gt;</span><span class="si">{</span><span class="n">expr</span><span class="p">[</span><span class="n">exc</span><span class="o">.</span><span class="n">offset</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s2">&lt;/b&gt;&#39;&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;Syntax error in expression &#39;</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">expr</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="_check_free_variables"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._check_free_variables">[docs]</a><span class="k">def</span> <span class="nf">_check_free_variables</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">symbol_table</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">undefined</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">_symbols</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                 <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">symbol_table</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">iskeyword</span><span class="p">(</span><span class="n">sym</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">undefined</span><span class="p">:</span>
        <span class="n">undefined_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">undefined</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">html</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">undefined</span><span class="p">:</span>
                <span class="c1"># Identify the symbol for replacement as everything between a</span>
                <span class="c1"># word boundary. Since symbols can contain &#39;.&#39;, we need to</span>
                <span class="c1"># use negative lookbehind and negative lookahead on a</span>
                <span class="c1"># character set containing &#39;.&#39; to check for the boundaries.</span>
                <span class="c1"># Also, if there is a &#39;.&#39; in the symbol it could match any</span>
                <span class="c1"># character, so it needs to be turned into a regular</span>
                <span class="c1"># expression that matches &#39;.&#39;.</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(?&lt;![a-zA-Z0-9_.])</span><span class="si">{</span><span class="n">symbol</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;[.]&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">(?![a-zA-Z0-9_.])&quot;</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;&lt;b&gt;</span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&lt;/b&gt;&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;Unknown parameters (</span><span class="si">%s</span><span class="s2">) in expression &#39;</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">undefined_str</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">expr</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;Unknown parameters (</span><span class="si">%s</span><span class="s2">) in expression &#39;</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">undefined_str</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">expr</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[]</span></div>

<span class="c1"># simple pattern which matches symbols.  Note that it will also match</span>
<span class="c1"># invalid substrings such as a3...9, but given syntactically correct</span>
<span class="c1"># input it will only match symbols.</span>
<span class="n">_SYMBOL_PATTERN</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;([a-zA-Z_][a-zA-Z_0-9.]*)&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="_symbols"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._symbols">[docs]</a><span class="k">def</span> <span class="nf">_symbols</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">_SYMBOL_PATTERN</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span></div>

<div class="viewcode-block" id="_substitute"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._substitute">[docs]</a><span class="k">def</span> <span class="nf">_substitute</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace all occurrences of symbol s with mapping[s] for s in mapping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the symbols and the mapping</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mapping</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
               <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">_SYMBOL_PATTERN</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">]</span>

    <span class="c1"># Split the expression in to pieces, with new symbols replacing old</span>
    <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="n">pieces</span> <span class="o">+=</span> <span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">start</span><span class="p">],</span> <span class="n">text</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">end</span>
    <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="n">offset</span><span class="p">:])</span>

    <span class="c1"># Join the pieces and return them</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pieces</span><span class="p">)</span></div>

<div class="viewcode-block" id="_find_dependencies"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._find_dependencies">[docs]</a><span class="k">def</span> <span class="nf">_find_dependencies</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span> <span class="n">exprs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of pair-wise dependencies from the parameter expressions.</span>

<span class="sd">    *symtab* gives the *{&#39;parameter&#39;: value}* table of available parameters.</span>

<span class="sd">    *exprs* gives the *{&#39;parameter&#39;: &#39;expr&#39;}* table of parameter expressions.</span>

<span class="sd">    For example, if p3 = p1+p2, then find_dependencies([p1, p2, p3]) will</span>
<span class="sd">    return *[(&#39;p3&#39;, &#39;p1&#39;), (&#39;p3&#39;, &#39;p2&#39;)]*. For base expressions without</span>
<span class="sd">    dependencies, such as p4 = 2*pi, this should return *[(&#39;p4&#39;, None)]*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">exprs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">_dependent_symbols</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symtab</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">deps</span></div>

<span class="c1"># Hack to deal with expressions without dependencies --- return a fake</span>
<span class="c1"># dependency of None.</span>
<span class="c1"># The better solution is fix order_dependencies so that it takes a</span>
<span class="c1"># dictionary of {symbol: dependency_list}, for which no dependencies</span>
<span class="c1"># is simply []; fix in parameter_mapping as well</span>
<div class="viewcode-block" id="_dependent_symbols"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._dependent_symbols">[docs]</a><span class="k">def</span> <span class="nf">_dependent_symbols</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symtab</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an expression string and a symbol table, return the set of symbols</span>
<span class="sd">    used in the expression. Symbols are only returned once even if they occur</span>
<span class="sd">    multiple times. The return value is a set with the elements in no</span>
<span class="sd">    particular order. Returns a set containing *None* if no dependencies (as</span>
<span class="sd">    needed by *order_dependencies*).</span>

<span class="sd">    This is the first step in computing a dependency graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">_symbols</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">symtab</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">deps</span> <span class="k">if</span> <span class="n">deps</span> <span class="k">else</span> <span class="p">{</span><span class="kc">None</span><span class="p">}</span></div>

<div class="viewcode-block" id="_parameter_mapping"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._parameter_mapping">[docs]</a><span class="k">def</span> <span class="nf">_parameter_mapping</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the parameter substitution we need so that expressions can</span>
<span class="sd">    be evaluated without having to traverse a chain of</span>
<span class="sd">    model.layer.parameter.value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">pairs</span><span class="p">)</span>
    <span class="n">pars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span>
    <span class="n">definition</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="s1">&#39;P</span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pars</span><span class="p">)</span> <span class="p">)</span>
    <span class="c1"># p is None when there is an expression with no dependencies</span>
    <span class="n">substitution</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="s1">&#39;P</span><span class="si">%d</span><span class="s1">.value&#39;</span><span class="o">%</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">pars</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">definition</span><span class="p">,</span> <span class="n">substitution</span></div>

<div class="viewcode-block" id="no_constraints"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression.no_constraints">[docs]</a><span class="k">def</span> <span class="nf">no_constraints</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This parameter set has no constraints between the parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="compile_constraints"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression.compile_constraints">[docs]</a><span class="k">def</span> <span class="nf">compile_constraints</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build and return a function to evaluate all parameter expressions in</span>
<span class="sd">    the proper order.</span>

<span class="sd">    Input:</span>

<span class="sd">        *symtab* is the symbol table for the model: { &#39;name&#39;: parameter }</span>

<span class="sd">        *exprs* is the set of computed symbols: { &#39;name&#39;: &#39;expression&#39; }</span>

<span class="sd">        *context* is any additional context needed to evaluate the expression</span>

<span class="sd">    Return:</span>

<span class="sd">        updater function which sets parameter.value for each expression</span>

<span class="sd">    Raises:</span>

<span class="sd">       RunTimeError if any expression contains a syntax error, if any</span>
<span class="sd">       symbol used is not defined, or if there are circular dependencies</span>
<span class="sd">       between symbols. Runtime error argument is a string describing all</span>
<span class="sd">       found errors.</span>

<span class="sd">    This function is not terribly sophisticated, and it would be easy to</span>
<span class="sd">    trick.  However it handles the common cases cleanly and generates</span>
<span class="sd">    reasonable messages for the common errors.</span>

<span class="sd">    This code has not been fully audited for security.  While we have</span>
<span class="sd">    removed the builtins and the ability to import modules, there may</span>
<span class="sd">    be other vectors for users to perform more than simple function</span>
<span class="sd">    evaluations. Unauthenticated users should not be running this code.</span>

<span class="sd">    Parameter names are assumed to contain only _.a-zA-Z0-9#[]</span>

<span class="sd">    Both names are provided for inverse functions, e.g., acos and arccos.</span>

<span class="sd">    Should try running the function to identify syntax errors before</span>
<span class="sd">    running it in a fit.</span>

<span class="sd">    Use help(fn) to see the code generated for the returned function fn.</span>
<span class="sd">    dis.dis(fn) will show the corresponding python vm instructions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">retfn</span><span class="p">,</span> <span class="n">errors</span> <span class="o">=</span> <span class="n">_compile_constraints</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">retfn</span></div>

<span class="c1"># Simple parameter class for checking constraints</span>
<div class="viewcode-block" id="_Parameter"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._Parameter">[docs]</a><span class="k">class</span> <span class="nc">_Parameter</span><span class="p">:</span>
<div class="viewcode-block" id="_Parameter.__init__"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._Parameter.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span></div></div>

<div class="viewcode-block" id="check_constraints"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression.check_constraints">[docs]</a><span class="k">def</span> <span class="nf">check_constraints</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="p">{},</span> <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of errors in *exprs* or the empty list if there are none.</span>
<span class="sd">    If the html flag is set to True, the list elements will have html &lt;b&gt;</span>
<span class="sd">    markups that allow the caller to control rendering:</span>

<span class="sd">    Unknown symbol: tags unknown symbols in *exprs*</span>
<span class="sd">    Syntax error: tags the beginning of a syntax error in *exprs*</span>
<span class="sd">    Cyclic dependency: tags comma separated parameters that have</span>
<span class="sd">    cyclic dependency</span>

<span class="sd">    All symbols must exist in *context* or in *symtab*. The symbols in</span>
<span class="sd">    *context* should be constants or functions. The symbols in *symtab*</span>
<span class="sd">    can be constants or parameter objects with a *value* attribute.</span>

<span class="sd">    It first runs :func:`compile_constraints`, returning a list of errors</span>
<span class="sd">    if any. If there are no errors it runs the compiled constraints function,</span>
<span class="sd">    returning any errors it produces. Any parameters in *symtab* are copied</span>
<span class="sd">    with a shallow copy so they aren&#39;t overridden when the constraints are run.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure the symbols are wrapped in parameter objects. This allows</span>
    <span class="c1"># us to run the function and check constraints.</span>
    <span class="n">symtab</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">_Parameter</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
              <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">symtab</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">retfn</span><span class="p">,</span> <span class="n">errors</span> <span class="o">=</span> <span class="n">_compile_constraints</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span>
                                         <span class="n">exprs</span><span class="p">,</span>
                                         <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
                                         <span class="n">html</span><span class="o">=</span><span class="n">html</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">retfn</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">errors</span></div>

<div class="viewcode-block" id="_compile_constraints"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._compile_constraints">[docs]</a><span class="k">def</span> <span class="nf">_compile_constraints</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="p">{},</span> <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Check the syntax before compiling the complete function.</span>
    <span class="n">available_symbols</span> <span class="o">=</span> <span class="n">standard_symbols</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="n">available_symbols</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">symtab</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">exprs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_check_syntax</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="n">html</span><span class="p">))</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_check_free_variables</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">available_symbols</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="n">html</span><span class="p">))</span>

    <span class="c1"># Sort the parameters in the order they need to be evaluated</span>
    <span class="c1"># Note: order_dependencies raises an error if there are cyclic dependencies</span>
    <span class="n">deps</span> <span class="o">=</span> <span class="n">_find_dependencies</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span> <span class="n">exprs</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">deps</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">no_constraints</span><span class="p">,</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order_dependencies</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">html</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Cyclic dependency amongst parameters: &quot;</span>
                          <span class="s2">&quot;&lt;b&gt;</span><span class="si">%s</span><span class="s2">&lt;/b&gt;&quot;</span>
                          <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Cyclic dependency amongst parameters: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">errors</span>

    <span class="c1"># Rather than using the full path to the parameters in the parameter</span>
    <span class="c1"># expressions, instead use Pn, and substitute Pn.value for each occurrence</span>
    <span class="c1"># of the parameter in the expression.</span>
    <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">symtab</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="s1">&#39;P</span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">i</span><span class="p">,</span> <span class="n">symtab</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;P</span><span class="si">%d</span><span class="s1">.value&#39;</span><span class="o">%</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>

    <span class="c1"># Add the parameters to the global context</span>
    <span class="n">global_context</span> <span class="o">=</span> <span class="n">standard_symbols</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="n">global_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
    <span class="n">local_context</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Define the constraints function</span>
    <span class="n">assignments</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;=&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">exprs</span><span class="p">[</span><span class="n">p</span><span class="p">]))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>
    <span class="n">code</span> <span class="o">=</span> <span class="p">[</span><span class="n">_substitute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">assignments</span><span class="p">]</span>
    <span class="c1"># TODO: maybe wrap body in try...except block and return NaN?</span>
    <span class="n">functiondef</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def eval_expressions():</span>
<span class="s2">    &#39;&#39;&#39;</span>
<span class="s2">    </span><span class="si">%s</span>
<span class="s2">    &#39;&#39;&#39;</span>
<span class="s2">    </span><span class="si">%s</span>
<span class="s2">    return 0</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assignments</span><span class="p">),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>

    <span class="c1">#print(&quot; &quot;, &quot;\n  &quot;.join(code))</span>
    <span class="c1">#print(&quot;Function: &quot;+functiondef)</span>
    <span class="c1"># CRUFT: python &lt; 3.0;  doc builder isn&#39;t allowing the following exec</span>
    <span class="c1"># https://stackoverflow.com/questions/4484872/why-doesnt-exec-work-in-a-function-with-a-subfunction/41368813#comment73790496_41368813</span>
    <span class="c1">#exec(functiondef, global_context, local_context)</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">functiondef</span>
    <span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assignments</span><span class="p">)</span>
    <span class="nb">eval</span><span class="p">(</span><span class="nb">compile</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="s1">&#39;exec&#39;</span><span class="p">),</span> <span class="n">global_context</span><span class="p">,</span> <span class="n">local_context</span><span class="p">)</span>
    <span class="n">retfn</span> <span class="o">=</span> <span class="n">local_context</span><span class="p">[</span><span class="s1">&#39;eval_expressions&#39;</span><span class="p">]</span>

    <span class="c1"># Remove garbage added to globals by exec</span>
    <span class="n">global_context</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">global_context</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">global_context</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;__file__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">global_context</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;__builtins__&#39;</span><span class="p">)</span>
    <span class="c1">#print globals.keys()</span>

    <span class="k">return</span> <span class="n">retfn</span><span class="p">,</span> <span class="n">errors</span></div>

<div class="viewcode-block" id="order_dependencies"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression.order_dependencies">[docs]</a><span class="k">def</span> <span class="nf">order_dependencies</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Order elements from pairs so that b comes before a in the</span>
<span class="sd">    ordered list for all pairs (a, b).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(&quot;order_dependencies&quot;, pairs)</span>
    <span class="n">emptyset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Break pairs into left set and right set</span>
    <span class="c1"># Note: pairs is array or list, so use &quot;len(pairs) &gt; 0&quot; to check for empty.</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">pairs</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">([],</span> <span class="p">[])</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#print &quot;within&quot;, pairs</span>
        <span class="c1"># Find which items only occur on the right</span>
        <span class="n">independent</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
        <span class="k">if</span> <span class="n">independent</span> <span class="o">==</span> <span class="n">emptyset</span><span class="p">:</span>
            <span class="n">cycleset</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">left</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">cycleset</span><span class="p">)</span>

        <span class="c1"># The possibly resolvable items are those that depend on the independents</span>
        <span class="n">dependent</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">independent</span><span class="p">])</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">independent</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="n">dependent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">pairs</span><span class="p">)]</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="n">dependent</span> <span class="o">-</span> <span class="n">left</span>
        <span class="c1">#print &quot;independent&quot;, independent, &quot;dependent&quot;, dependent, &quot;resolvable&quot;, resolved</span>
        <span class="n">order</span> <span class="o">+=</span> <span class="n">resolved</span>
        <span class="c1">#print &quot;new order&quot;, order</span>
    <span class="n">order</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">order</span></div>

<span class="c1"># ========= Test code ========</span>
<div class="viewcode-block" id="_check"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression._check">[docs]</a><span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Verify that the list n contains the given items, and that the list</span>
<span class="sd">    satisfies the partial ordering given by the pairs in partial order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: pairs is array or list, so use &quot;len(pairs) &gt; 0&quot; to check for empty.</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">pairs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">([],</span> <span class="p">[])</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">order_dependencies</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">items</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
        <span class="n">n</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="n">items</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> expect </span><span class="si">%s</span><span class="s2"> to contain </span><span class="si">%s</span><span class="s2"> for </span><span class="si">%s</span><span class="s2">&quot;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">pairs</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lo</span> <span class="ow">in</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">hi</span> <span class="ow">in</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">hi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> expect </span><span class="si">%s</span><span class="s2"> before </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2"> for </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">pairs</span><span class="p">))</span></div>

<div class="viewcode-block" id="test_deps"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression.test_deps">[docs]</a><span class="k">def</span> <span class="nf">test_deps</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="c1"># Null case</span>
    <span class="n">_check</span><span class="p">(</span><span class="s2">&quot;test empty&quot;</span><span class="p">,</span> <span class="p">[])</span>

    <span class="c1"># Some dependencies</span>
    <span class="n">_check</span><span class="p">(</span><span class="s2">&quot;test1&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
    <span class="n">_check</span><span class="p">(</span><span class="s2">&quot;test1 renumbered&quot;</span><span class="p">,</span>
           <span class="p">[(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
    <span class="n">_check</span><span class="p">(</span><span class="s2">&quot;test1 numpy&quot;</span><span class="p">,</span>
           <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]))</span>

    <span class="c1"># No dependencies</span>
    <span class="n">_check</span><span class="p">(</span><span class="s2">&quot;test2&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>

    <span class="c1"># Cycle test</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">order_dependencies</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;test3 expect ValueError exception for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pairs</span><span class="p">,))</span>

    <span class="c1"># large test for gross speed check</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">4000</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">A</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">4000</span>  <span class="c1"># Avoid cycles</span>
    <span class="n">_check</span><span class="p">(</span><span class="s2">&quot;test-large&quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

    <span class="c1"># depth tests</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">_check</span><span class="p">(</span><span class="s2">&quot;depth-1&quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">_check</span><span class="p">(</span><span class="s2">&quot;depth-2&quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span></div>

<div class="viewcode-block" id="test_expr"><a class="viewcode-back" href="../../../../dev/sasview-api/sas.sascalc.fit.html#sas.sascalc.fit.expression.test_expr">[docs]</a><span class="k">def</span> <span class="nf">test_expr</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">inspect</span>
    <span class="kn">import</span> <span class="nn">dis</span>

    <span class="n">symtab</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a.b.x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a.c&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a.b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b.x&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="s1">&#39;a.b.x + sin(4*pi*a.c) + a.b.x/a.b&#39;</span>

    <span class="c1"># Check symbol lookup</span>
    <span class="k">assert</span> <span class="n">_dependent_symbols</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symtab</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;a.b.x&#39;</span><span class="p">,</span> <span class="s1">&#39;a.c&#39;</span><span class="p">,</span> <span class="s1">&#39;a.b&#39;</span><span class="p">])</span>

    <span class="c1"># Check symbol rename</span>
    <span class="k">assert</span> <span class="n">_substitute</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a.b.x&#39;</span><span class="p">:</span> <span class="s1">&#39;Q&#39;</span><span class="p">})</span> <span class="o">==</span> <span class="s1">&#39;Q + sin(4*pi*a.c) + Q/a.b&#39;</span>
    <span class="k">assert</span> <span class="n">_substitute</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a.b&#39;</span><span class="p">:</span> <span class="s1">&#39;Q&#39;</span><span class="p">})</span> <span class="o">==</span> <span class="s1">&#39;a.b.x + sin(4*pi*a.c) + a.b.x/Q&#39;</span>

    <span class="c1"># Check dependency builder</span>
    <span class="c1"># Fake parameter class</span>
    <span class="k">class</span> <span class="nc">TestParameter</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="k">def</span> <span class="nf">iscomputed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscomputed</span><span class="p">()</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="n">value</span>
    <span class="k">def</span> <span class="nf">world</span><span class="p">(</span><span class="o">*</span><span class="n">pars</span><span class="p">):</span>
        <span class="n">symtab</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">)</span>
        <span class="n">exprs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">expression</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pars</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">iscomputed</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">symtab</span><span class="p">,</span> <span class="n">exprs</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">TestParameter</span><span class="p">(</span><span class="s1">&#39;G0.sigma&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">TestParameter</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="s1">&#39;2*pi*sin(G0.sigma/.1875) + M1.G1&#39;</span><span class="p">)</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">TestParameter</span><span class="p">(</span><span class="s1">&#39;M1.G1&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">p3_circular</span> <span class="o">=</span> <span class="n">TestParameter</span><span class="p">(</span><span class="s1">&#39;M1.G1&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="s1">&#39;other + 6&#39;</span><span class="p">)</span>
    <span class="n">p3_self</span> <span class="o">=</span> <span class="n">TestParameter</span><span class="p">(</span><span class="s1">&#39;M1.G1&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="s1">&#39;M1.G1&#39;</span><span class="p">)</span>
    <span class="n">p4</span> <span class="o">=</span> <span class="n">TestParameter</span><span class="p">(</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="s1">&#39;2*pi*35&#39;</span><span class="p">)</span>
    <span class="c1"># Simple chain</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">_find_dependencies</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">)))</span>
            <span class="o">==</span> <span class="nb">set</span><span class="p">([(</span><span class="n">p2</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">path</span><span class="p">),</span> <span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">p3</span><span class="o">.</span><span class="n">path</span><span class="p">)]))</span>
    <span class="c1"># Constant expression</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">_find_dependencies</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p4</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([(</span><span class="n">p4</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
    <span class="c1"># No dependencies</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">_find_dependencies</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p3</span><span class="p">)))</span>

    <span class="c1"># Check function builder</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">compile_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">))</span>

    <span class="c1"># Inspect the resulting function</span>
    <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getdoc</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>

    <span class="c1"># Evaluate the function and see if it updates the</span>
    <span class="c1"># target value as expected</span>
    <span class="n">fn</span><span class="p">()</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mf">.1875</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span>
    <span class="k">assert</span> <span class="n">p2</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">expected</span><span class="p">,</span> <span class="s2">&quot;Value was </span><span class="si">%s</span><span class="s2">, not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>

    <span class="c1"># Make sure check_constraints returns an empty list for these expressions.</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">check_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">))</span>

    <span class="c1"># Check empty dependency set doesn&#39;t crash</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">compile_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p3</span><span class="p">))</span>
    <span class="n">fn</span><span class="p">()</span>

    <span class="c1"># Check that constants are evaluated properly</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">compile_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p4</span><span class="p">))</span>
    <span class="n">fn</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">p4</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">35</span>

    <span class="c1"># Check that circular definitions get flagged</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">compile_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3_circular</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Cyclic&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;failed to raise error for cyclic dependency&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">compile_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3_self</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Cyclic&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;failed to raise error for self dependency&quot;</span><span class="p">)</span>

    <span class="c1"># Make sure errors are returned from check_constraints</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="n">check_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3_circular</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Cyclic&#39;</span><span class="p">)</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="n">check_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3_self</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Cyclic&#39;</span><span class="p">)</span>

    <span class="c1"># Check additional context example; this also tests multiple expressions</span>
    <span class="n">tbl</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tbl_Si&#39;</span><span class="p">:</span> <span class="mf">2.09</span><span class="p">}</span>
    <span class="n">p5</span> <span class="o">=</span> <span class="n">TestParameter</span><span class="p">(</span><span class="s1">&#39;lookup&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="s2">&quot;tbl_Si&quot;</span><span class="p">)</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">compile_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p5</span><span class="p">),</span> <span class="n">context</span><span class="o">=</span><span class="n">tbl</span><span class="p">)</span>
    <span class="n">fn</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">p5</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mf">2.09</span><span class="p">,</span> <span class="s2">&quot;Value for </span><span class="si">%s</span><span class="s2"> was </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p5</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">p5</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="c1">#class Table:</span>
    <span class="c1">#    Si = 2.09</span>
    <span class="c1">#    values = {&#39;Si&#39;: 2.07}</span>
    <span class="c1">#tbl = Table()</span>
    <span class="c1">#p5 = TestParameter(&#39;lookup&#39;, expression=&quot;tbl.Si&quot;)</span>
    <span class="c1">#fn = compile_constraints(*world(p1, p2, p3, p5), context=dict(tbl=tbl))</span>
    <span class="c1">#fn()</span>
    <span class="c1">#assert p5.value == 2.09, &quot;Value for %s was %s&quot;%(p5.expression, p5.value)</span>
    <span class="c1">#</span>
    <span class="c1">#p5.expression = &quot;tbl.values[&#39;Si&#39;]&quot;</span>
    <span class="c1">#fn = compile_constraints(*world(p1, p2, p3, p5), context=dict(tbl=tbl))</span>
    <span class="c1">#fn()</span>
    <span class="c1">#assert p5.value == 2.07, &quot;Value for %s was %s&quot; % (p5.expression, p5.value)</span>

    <span class="c1"># Verify that we capture invalid expressions</span>
    <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;G4.cage&#39;</span><span class="p">,</span> <span class="s1">&#39;M0.cage&#39;</span><span class="p">,</span> <span class="s1">&#39;M1.G1 + *2&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;piddle&#39;</span><span class="p">,</span>
                 <span class="c1">#&#39;5; import sys; print(&quot;p0wned&quot;)&#39;,</span>
                 <span class="s1">&#39;__import__(&quot;sys&quot;).argv&#39;</span>
                 <span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">p6</span> <span class="o">=</span> <span class="n">TestParameter</span><span class="p">(</span><span class="s1">&#39;broken&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">compile_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">world</span><span class="p">(</span><span class="n">p6</span><span class="p">))</span>
            <span class="n">fn</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
            <span class="c1">#print(msg)</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to raise error for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">expr</span><span class="p">,))</span>

    <span class="c1"># Verify that check_constraints returns multiple errors.</span>
    <span class="n">symtab</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;M1.sld&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="s1">&#39;M1.sld_solvent&#39;</span><span class="p">:</span> <span class="mf">6.0</span><span class="p">,</span>
        <span class="s1">&#39;M1.radius&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
        <span class="s1">&#39;M1.scale&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">exprs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;M1.background&#39;</span><span class="p">:</span> <span class="s1">&#39;M1.scal/1e5&#39;</span><span class="p">,</span>
        <span class="s1">&#39;M1.sld&#39;</span><span class="p">:</span> <span class="s1">&#39;M1.sld_solvent + 1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;M1.sld_solvent&#39;</span><span class="p">:</span> <span class="s1">&#39;M1.sld + 2&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="n">check_constraints</span><span class="p">(</span><span class="n">symtab</span><span class="p">,</span> <span class="n">exprs</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span></div>
    <span class="c1">#print(&quot;\n&quot;.join(errors))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">test_expr</span><span class="p">()</span>
    <span class="n">test_deps</span><span class="p">()</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SasView 5.0.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../sas.html" >sas</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">sas.sascalc.fit.expression</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, The SasView Project.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.1.
    </div>
  </body>
</html>